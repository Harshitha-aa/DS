1. You are given two non-empty linked lists representing two non-negative integers. The digits
are stored in reverse order, and each of their nodes contains a single digit. Add the two
numbers and return the sum as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
Example 1:
Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
Explanation: 342 + 465 = 807.
 code:
#include<stdio.h>
#include<stdlib.h>

struct node1 {
    int d;
    struct node1* next;
};

struct node1* create1() {
    struct node1* head1;
    head1 = (struct node1*)malloc(sizeof(struct node1));
    head1->next = NULL;
    return head1;
}

void insert1(struct node1* head1, int e) {
    struct node1* nn = (struct node1*)malloc(sizeof(struct node1));
    nn->d = e;
    nn->next = head1->next;
    head1->next = nn;
}

struct node2 {
    int d;
    struct node2* next;
};

struct node2* create2() {
    struct node2* head2;
    head2 = (struct node2*)malloc(sizeof(struct node2));
    head2->next = NULL;
    return head2;
}

void insert2(struct node2* head2, int e) {
    struct node2* nn = (struct node2*)malloc(sizeof(struct node2));
    nn->d = e;
    nn->next = head2->next;
    head2->next = nn;
}

struct node3 {
    int d;
    struct node3* next;
    struct node3* prev;
};

struct node3* newnode() {
    struct node3* head3 = (struct node3*)malloc(sizeof(struct node3));
    head3->next = NULL;
    head3->prev=NULL;
    return head3;
}

void insert3(struct node3* head3, int element) {
    struct node3* nn = (struct node3*)malloc(sizeof(struct node3));
    nn->d = element;
    nn->next = head3->next;
    nn->prev=head3;
    head3->next = nn;
    if(nn->next!=NULL)
    {
        nn->next->prev=nn;
    }
}

void display(struct node3* head3) {
    struct node3* last=head3;
    while(last->next!=NULL)
    {
        last=last->next;
    }
    while(last->prev!=NULL)
    {
        printf("%d",last->d);
        last=last->prev;
    }
}


void add(struct node1* head1, struct node2* head2, struct node3* head3) {
    struct node1* temp1 = head1->next;
    struct node2* temp2 = head2->next;
    int reminder = 0;

    while (temp1 != NULL || temp2 != NULL || reminder>0) {
        int a = (temp1 != NULL) ? temp1->d : 0;
        int b = (temp2 != NULL) ? temp2->d : 0;
        int sum = a + b + reminder;
        reminder = sum / 10;
        int digit = sum % 10;

        insert3(head3, digit);

        if (temp1 != NULL) temp1 = temp1->next;
        if (temp2 != NULL) temp2 = temp2->next;
    }
}

int main() {
    struct node1* head1 = create1();
    struct node2* head2 = create2();
    struct node3* head3 = newnode();  

    // inserting [2, 4, 3] → represents 342
    insert1(head1, 9);
    insert1(head1, 9);
    insert1(head1, 9);
    insert1(head1, 9);
    insert1(head1, 9);
    insert1(head1, 9);
    insert1(head1, 9);

    // inserting [5, 6, 4] → represents 465
    insert2(head2, 9);
    insert2(head2, 9);
    insert2(head2, 9);
    insert2(head2, 9);

    add(head1, head2, head3);  // ✅ updated: pass head3 to add()

    display(head3);  // Output: 708

    return 0;
}



2.Given the head of a linked list, remove the nth node from the end of the list and return its
head.
code:
#include<stdio.h>
#include<stdlib.h>
struct node
{
    int d;
    struct node* next;
    struct node* prev;
};
struct node* create()
{
    struct node* head=(struct node*)malloc(sizeof(struct node));
    head->next=NULL;
    head->prev=NULL;
    return head;
}
void insert(struct node* head,int e)
{
    struct node* nn=(struct node*)malloc(sizeof(struct node));
    nn->d=e;
    nn->next=head->next;
    nn->prev=head;
    head->next=nn;
    if(nn->next!=NULL)
    {
        nn->next->prev=nn;
    }
}
void delete(struct node* head,int pos)
{
    struct node* last;
    last=head;
    while(last->next!=NULL)
    {
        last=last->next;
    }
    int i=1;
    while(last->prev!=NULL && i<pos)
    {
        last=last->prev;
        i++;
    }
    if(last->prev==NULL)
    {
        printf("pos exceeds len");
    }
    else
    {
        last->prev->next=last->next;
        last->next->prev=last->prev;
    }
}
void display(struct node* head)
{
    struct node* temp;
    temp=head->next;
    while(temp!=NULL)
    {
        printf("%d",temp->d);
        temp=temp->next;
    }
}
int main()
{
    struct node* head=create();
    insert(head,1);
    insert(head,2);
    insert(head,3);
    insert(head,4);
    insert(head,5);
    insert(head,6);
    int n;
    scanf("%d",&n);
    display(head);
    delete(head,n);
    display(head);
    return 0;
}


32.32. You are given the head of a linked list, and an integer k.
Return the head of the linked list after swapping the values of the kth node from the beginning and
the kth node from the end (the list is 1-indexed).
code:
#include<stdio.h>
#include<stdlib.h>
struct node
{
    int d;
    struct node* next;
    struct node* prev;
};
struct node* create()
{
    struct node* head=(struct node*)malloc(sizeof(struct node));
    head->next=NULL;
    head->prev=NULL;
    return head;
}
void insert(struct node* head,int e)
{
    struct node* nn=(struct node*)malloc(sizeof(struct node));
    nn->d=e;
    nn->next=head->next;
    nn->prev=head;
    head->next=nn;
    if(nn->next!=NULL)
    {
        nn->next->prev=nn;
    }
}
void search(struct node* head,int pos)
{
    struct node* last;
    last=head;
    while(last->next!=NULL)
    {
        last=last->next;
    }
    int i=1;
    while(last->prev!=NULL && i<pos)
    {
        last=last->prev;
        i++;
    }
    struct node* front;
    front=head->next;
    int j=1;
    while(front->next!=NULL && j<pos)
    {
        front=front->next;
        j++;
    }
    int a=front->d;
    int b=last->d;
    front->d=b;
    last->d=a;
    
}
void display(struct node* head)
{
    struct node* temp;
    temp=head->next;
    while(temp!=NULL)
    {
        printf("%d",temp->d);
        temp=temp->next;
    }
    printf("\n");
}
int main()
{
    struct node* head=create();
    insert(head,1);
    insert(head,2);
    insert(head,3);
    insert(head,4);
    insert(head,5);
    insert(head,6);
    int n;
    scanf("%d",&n);
    display(head);
    search(head,n);
    display(head);
    return 0;
}


30. Given head which is a reference node to a singly-linked list. The value of each node in the
linked list is either 0 or 1. The linked list holds the binary representation of a number.
Return the decimal value of the number in the linked list.
The most significant bit is at the head of the linked list.

code:

#include <stdio.h>
#include <stdlib.h>
#include<math.h>

struct node
{
    int d;
    struct node* next;
    struct node* prev;
};

struct node* create()
{
    struct node* head = (struct node*)malloc(sizeof(struct node));
    head->next = NULL;
    head->prev = NULL;
    return head;
}

void insert(struct node* head, int e)
{
    struct node* nn = (struct node*)malloc(sizeof(struct node));
    nn->d = e;
    nn->next = head->next;
    nn->prev = head;
    head->next = nn;
    if (nn->next != NULL)
    {
        nn->next->prev = nn;
    }
}
void number(struct node* head)
{
    long long num=0;
    struct node* temp=head->next;
    while(temp!=NULL)
    {
        num=num*10+(temp->d);
        temp=temp->next;
    }
    int decimal=0,i=0,rem;
    while(num!=0)
    {
        rem=num%10;
        decimal=decimal+rem*pow(2,i);
        num=num/10;
        i++;
    }
    printf("%d",decimal);
}
void display(struct node* head)
{
    struct node* temp = head->next;
    while (temp != NULL)
    {
        printf("%d", temp->d);
        temp = temp->next;
    }
    printf("\n");
}
int main()
{
    struct node* head = create();
    insert(head, 1);
    insert(head, 0);
    insert(head, 1);
    number(head);
}

28. Given the head of a singly linked list, return the middle node of the linked list.
If there are two middle nodes, return the second middle node.

code:

#include <stdio.h>
#include <stdlib.h>
#include<math.h>
#include<string.h>

struct node
{
    int d;
    struct node* next;
    struct node* prev;
};

struct node* create()
{
    struct node* head = (struct node*)malloc(sizeof(struct node));
    head->next = NULL;
    head->prev = NULL;
    return head;
}

void insert(struct node* head, int e)
{
    struct node* nn = (struct node*)malloc(sizeof(struct node));
    nn->d = e;
    nn->next = head->next;
    nn->prev = head;
    head->next = nn;
    if (nn->next != NULL)
    {
        nn->next->prev = nn;
    }
}
void length(struct node* head)
{
    int len=1;
    struct node* temp=head->next;
    while(temp!=NULL)
    {
        temp=temp->next;
        len++;
    }
    int rl;
    if(len%2!=0)
    {
        rl=len/2;
    }
    else
    {
     rl=(len/2)+1;
    }
    int i=1;
    struct node*t=head->next;
    while(t!=NULL && i<rl)
    {
        t=t->next;
        i++;
    }
    printf("%d",t->d);
}

int main()
{
    struct node* head = create();
    insert(head, 1);
    insert(head, 1);
    insert(head, 1);
     insert(head, 29);
      insert(head, 1);
       insert(head, 1);
    length(head);
}
